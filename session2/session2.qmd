---
title: "R Foundations: Functions and Iteration"
author: "Aditya Ranganath"
format: 
  html:
    toc: true 
    toc-depth: 2
    toc-expand: 2
    number-sections: true
    number-depth: 3
editor: visual
---

# Built-In Functions

```{r}
# creates a new numeric vector and assigns it to a new object named "sample_vector"
sample_vector<-c(5, 11, 5.6, 8)

# prints contents of "sample_vector"
sample_vector
```

```{r}
# calculates sum of vector elements using built-in "sum" function
sum(sample_vector)
```

```{r}
# calculates product of vector elements using built-in "prod" function
prod(sample_vector)
```

```{r}
# calculates the mean of vector elements
mean(sample_vector)
```

```{r}
# calculates the median of vector elements
median(sample_vector)
```

```{r}
# calculates the number of characters in a string
nchar("Hello, World!")
```

```{r}
# extracts rownames for "mtcars" dataset, which is built into R
rownames(mtcars)
```

# Packages

## Installing Packages

```{r}
#| eval: FALSE
install.packages("tidyverse")
```

## Loading Libraries

```{r}
#| message: FALSE
library(tidyverse)
```

# Writing Custom Functions

As we mentioned earlier, a function is a programming construct that takes a set of inputs (also known as arguments), manipulates those inputs/arguments in a specific way (the body of the function), and returns an output that is the product of how those inputs are manipulated in the body of the function. It is much like a recipe, where the recipe's ingredients are analogous to a function's inputs, the instructions about how to combine and process those ingredients are analogous to the body of the function, and the end product of the recipe (for example, a cake) is analogous to the function's output. R packages are essentially pre-written collections of functions organized around a given theme, and for most data processing and analysis tasks, one can rely on these pre-written functions embedded within packages (which we will do starting tomorrow). In some cases, however, you may want to write your own functions from scratch; it is also useful to have a basic sense of how functions work and are put together, so that you can use pre-written package-based functions more effectively.

Why might you want to write your own functions?

-   Sometimes, there won't be a convenient pre-programmed function available to accomplish a given task, which will require you to write your own custom function.
-   Writing your own functions will allow you to automate your workflows
-   Writing functions will allow you to write more concise and readable code.

Writing your own functions can be challenging, but this section will provide you with some basic intuition for how the process works. To develop this intuition, we'll begin with a very simple example.

## One-Input Fahrenheit to Celsius Function

Let's say you have a large collection of temperature data, measured in Fahrenheit, and you want to convert these data to Celsius. Recall that the formula to convert from Fahrenheit to Celsius is the following, where "C" represents temperature in Celsius, and "F" represents temperature in Fahrenheit:

```{r}
#| eval: FALSE
# fahrenheit to Celsius formula, where C is Celsius output and F is Fahrenheit input
(F-32)*(5/9)=C
```

As we discussed

```{r}
# Converts 55 degrees fahrenheit to Celsius
(55-32)*(5/9)
```

```{r}
# creates fahrenheit to celsius conversion function and assigns it to a new object named "fahrenheit_to_celsius_converter"
fahrenheit_to_celsius_converter<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*5/9
  return(celsius_output)
}
```

```{r}
# tests function using an input of 68 degrees fahrenheit
fahrenheit_to_celsius_converter(68)
```

```{r}
# uses "fahrenheit_to_celsius_converter" function using an input of 20 degrees fahrenheit
fahrenheit_to_celsius_converter(22)
```

## Two-Input Net Export Function

```{r}
# writes function that takes export and import values as inputs, and returns a value for net exports; function is assigned to a new object named "net_exports_calculation"
net_exports_calculation<-function(exports, imports){
  net_export_value<-exports-imports
  return(net_export_value)
}
```

```{r}
# tests the "net_exports_calculation" function in a case where exports are 133, and imports are 55
net_exports_calculation(exports=133, imports=55)
```

```{r}
# tests the "net_exports_calculation" function in a case where exports are 133, and imports are 55; does not explicitly label inputs
net_exports_calculation(133, 155)
```

If you don't label your inputs, the order in which input values are passed to the function matters; it is assumed that they are passed in the order they're defined in the function. If you

```{r}
# uses the "net_exports_calculation" function in a case where exports are 133, and imports are 55; since inputs are labelled, order does not matter
net_exports_calculation(imports=7543, exports=2342)
```

## Multiple-Input GDP Calculation Function

```{r}
# creates a new function that takes consumption spending, government spending, investment spending, and net exports as inputs, and returns a value for GDP by summing these elements; function is assigned to a new object named "gdp_calculation"
gdp_calculation<-
  function(consumption_spending, government_spending, investment_spending, net_exports){
  gdp<-consumption_spending+government_spending+investment_spending+net_exports
  return(gdp)
}
```

```{r}
# tests gdp calculation for consumption spending of 125, government spending of 66, investment spending of 36, and net exports of -33
gdp_calculation(consumption_spending = 125, government_spending=66, investment_spending=36, net_exports=-33)
```

## if-then Statements in Functions

```{r}
x<-6

if (x > 5) {
  print("x is greater than 5")
} else if (x == 5) {
  print("x is equal to 5")
} else {
  print("x is less than 5")
}
```

```{r}
convert_temperature <- function(value, unit) {
  if (unit == "Fahrenheit") {
    # Convert Fahrenheit to Celsius
    celsius <- (value - 32) * 5 / 9
    return(celsius)
  } else if (unit == "Celsius") {
    # Convert Celsius to Fahrenheit
    fahrenheit <- (value * 9 / 5) + 32
    return(fahrenheit)
  } else {
    # Handle invalid input for the unit
    return("Please indicate whether your input is in Celsius or Fahrenheit")
  }
}

```

```{r}
convert_temperature(100, "Fahrenheit")
```

```{r}
convert_temperature(25, "Celsius")
```

```{r}
convert_temperature(100, "Kelvin")
```

# Iteration

## Iteration with a Single-Input Function

```{r}
# creates a vector of fahrenheit inputs
fahrenheit_input_vector<-c(45.6, 95.9, 67.8, 43)
```

```{r}
# iteratively applies the "fahrenheit_to_celsius_converter" function to the vector of inputs, "fahrenheit_input_vector", and assigns the resulting list of outputs to "celsius_outputs_vector"
celsius_outputs_list<-map(.x=fahrenheit_input_vector, .f=fahrenheit_to_celsius_converter)
```

```{r}
# prints contents of "celsius_outputs_list"
celsius_outputs_list

```

```{r}
# iteratively applies the "fahrenheit_to_celsius_converter" function to the vector of inputs, "fahrenheit_input_vector", and assigns the resulting vector of outputs to "celsius_outputs_vector"
celsius_outputs_vector<-map_dbl(.x=fahrenheit_input_vector, fahrenheit_to_celsius_converter)
```

```{r}
# prints contents of "celsius_outputs_vector"
celsius_outputs_vector
```

```{r}
# makes a function that takes a fahrenheit input, and returns a data frame with one column containing the fahrenheit inputs, and the other containing the celsius outputs; assigns the function to a new object named "fahrenheit_to_celsius_converter_df"
fahrenheit_to_celsius_converter_df<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*(5/9)
  celsius_output_df<-data.frame(fahrenheit_input, celsius_output)
  return(celsius_output_df)
}
```

```{r}
# tests the "fahrenheit_to_celsius_converter_df" function for a fahrenheit input value of 44 degrees
fahrenheit_to_celsius_converter_df(fahrenheit_input=44)
```

```{r}
# iteratively applies the "fahrenheit_to_celsius_converter_df" function to the input values from "fahrenheit_input_vector" to create a data frame of temperature values; assigns this resulting data frame to a new object named "celsius_outputs_df"
celsius_outputs_df<-map_dfr(fahrenheit_input_vector, fahrenheit_to_celsius_converter_df)
```

```{r}
# prints contents of "celsius_outputs_df"
celsius_outputs_df
```

## Iteration with a Double-Input Function

```{r}
# creates export and import vectors
export_vector<-c(78, 499, 785)
import_vector<-c(134, 345, 645)
```

```{r}
# iteratively applies the "net_exports_calculation" function to the export values contained in "export_vector" and the import values contained in "import_vector" and deposits the resulting outputs in a list that's assigned to the new object entitled "net_export_list"
net_export_list<-map2(.x=export_vector, .y=import_vector, .f=net_exports_calculation)
```

```{r}
# prints contents of "net_export_list"
net_export_list
```

```{r}
# iteratively applies the "net_exports_calculation" function to the export values contained in "export_vector" and the import values contained in "import_vector" and deposits the resulting outputs in a vector that's assigned to the new object entitled "net_export_vector"
net_export_vector<-map2_dbl(.x=export_vector, .y=import_vector, .f=net_exports_calculation)
```

```{r}
# prints contents of "net_export_vector"
net_export_vector
```

```{r}
# creates new function that takes export and import values as inputs, and returns a data frame where the first column contains export values, the second column contains import values, and the third column contains net export values
net_exports_calculation_df<-function(exports, imports){
  net_exports<-exports-imports
  df<-data.frame(exports, imports, net_exports)
  return(df)
}
```

```{r}
# tests "net_exports_calculation_df" function with an export value of 100, and an import value of 40
net_exports_calculation_df(exports=100,imports=40)
```

```{r}
# # iteratively applies the "net_exports_calculation_df" function to the export values contained in "export_vector" and the import values contained in "import_vector" and deposits the resulting outputs in a data frame that's assigned to the new object entitled "net_exports_dataframe"
net_exports_dataframe<-map2_dfr(export_vector, import_vector, net_exports_calculation_df)
```

```{r}
# prints contents of "net_exports_dataframe"
net_exports_dataframe
```

## Iteration with a Multiple-Input Function

```{r}
gdp_input_list<-list(consumption_spending=c(44, 89, 64, 33),
                     government_spending=c(54, 76, 222, 110),
                     investment_spending=c(123, 200, 55, 45),
                     net_exports=c(-55, 89, 143,-12))
```

```{r}
gdp_output_list<-pmap(.l=gdp_input_list, .f=gdp_calculation)
```

```{r}
gdp_output_vector<-pmap_dbl(.l=gdp_input_list, .f=gdp_calculation)
```

As an exercise below, we'll ask you to write a function that takes arguments for consumption spending, government spending, investment spending, and net exports, and returns a data frame in which these values are columns, along with another column that contains the GDP value. We'll also ask you to use the `pmap_dfr()` function to create a new data frame using the input values contained in `gdp_input_list`(which we used above). Your code should yield a table that looks something like this:

```{r}
#| echo: FALSE
# writes function
gdp_calculation_df<-function(consumption_spending, government_spending, investment_spending, net_exports){
  gdp<-consumption_spending+government_spending+investment_spending+net_exports
  gdp_df<-data.frame(consumption_spending, government_spending, investment_spending, net_exports, gdp)
  return(gdp_df)
}

gdp_output_df<-pmap_dfr(gdp_input_list, gdp_calculation_df)

gdp_output_df
```

## Writing and Iteratively Applying More Complex Functions

Now, let's see how we can iteratively apply a more complex function with multiple inputs, and which makes use of "if-then" statements that result in different outputs depending on whether certain conditions are met. We'll slightly modify the `convert_temperature()` function we created above. In particular, this function will take three inputs; one specifies

```{r}
# creates new function to take a country name, temperature value in either Celsius or Fahrenheit, and a designation for the temperature unit as inputs, and return a data frame with the country name, temperature value in Fahrenheit, and Temperature value in Celsius as columns; the function is assigned to a new object named "convert_temperature_df"
convert_temperature_df <- function(country, temperature, unit) {
  # Check if the unit is valid
  if (unit == "Fahrenheit") {
    # Convert Fahrenheit to Celsius
    celsius <- (temperature - 32) * 5 / 9
    fahrenheit <- temperature
  } else if (unit == "Celsius") {
    # Convert Celsius to Fahrenheit
    fahrenheit <- (temperature * 9 / 5) + 32
    celsius <- temperature
  } else {
    # Throw an error if the unit is invalid
    stop("Error: Please indicate whether your input is in 'Celsius' or 'Fahrenheit'")
  }
  
  # Create and return a data frame
  result <- data.frame(
    Country = country,
    Temperature_Celsius = round(celsius, 2),   # Round to 2 decimal places
    Temperature_Fahrenheit = round(fahrenheit, 2)
  )
  
  return(result)
}

```

```{r}
# tests "convert_temperature_df" function for USA as the country input, and a temperature of 100 degrees in Fahrenheit
convert_temperature_df("USA", 100, "Fahrenheit")
```

```{r}
# creates a list of inputs to iterate over
input_list_temperatures<-list(country=c("USA", "Canada", "Mexico", "France"),
                              temperature=c(66, 11, 25, 33),
                              unit=c("Fahrenheit", "Celsius", "Fahrenheit", "Celsius"))
```

```{r}
# iteratively applies the "convert_temperature_df" function using the input variables in "input_list_temperatures"; the outputs are deposited in a list
pmap(input_list_temperatures, convert_temperature_df)
```

```{r}
# # iteratively applies the "convert_temperature_df" function using the input variables in "input_list_temperatures"; the outputs are deposited in a data frame
pmap_dfr(input_list_temperatures, convert_temperature_df)
```

Using previously developed functions in new functions, while also embedding iteration within a function.

```{r}
# Writes a function that takes a vector of fahrenheit temperature values, and returns either a list, data frame, or vector of outputs depending on the user's desired output; assigns the function to a new object named "fahrenheit_to_celsius_general"
fahrenheit_to_celsius_general<-function(vector_of_fahrenheit_inputs, desired_output){
   if (desired_output == "List") {
     outputlist<-map(.x=vector_of_fahrenheit_inputs, .f=fahrenheit_to_celsius_converter)
     return(outputlist)
   } else if (desired_output=="Vector"){
     outputvector<-map_dbl(.x=vector_of_fahrenheit_inputs, .f =fahrenheit_to_celsius_converter)
     return(outputvector)
   } else if (desired_output=="Data.Frame"){
     outputdf<-map_dfr(.x=vector_of_fahrenheit_inputs, .f=fahrenheit_to_celsius_converter_df)
     return(outputdf)
   } else {
      stop("Error: Please indicate whether your desired output is a 'Vector', 'Data.Frame', or 'List'")
   }
}

     
```

```{r}
# tests "fahrenheit_to_celsius_general" function; first, defines a vector of fahrenheit values
test_vector_ftoc<-c(18, 66, 88, -12, 7)

# uses "fahrenheit_to_celsius_general" function to convert the temperature values in "test_vector_ftoc" to Celsius and return a data frame with input Fahrenheit values in one column, and corresponding celsius temperatures in another column
fahrenheit_to_celsius_general(vector_of_fahrenheit_inputs=test_vector_ftoc, desired_output="Data.Frame")

```

```{r}
# uses "fahrenheit_to_celsius_general" function to convert the temperature values in "test_vector_ftoc" to Celsius and return the outputs as a list
fahrenheit_to_celsius_general(vector_of_fahrenheit_inputs=test_vector_ftoc, desired_output="List")
```

# Global and Local Environments

```{r}
# define a variable in the global environment
x<-24
```

```{r}
toy_function<-function(input1){
  x<-5
  z<-x+input1
  return(z)
}
```

```{r}
toy_function(input1=7)
```

```{r}
# prints value of x
x
```

```{r}
#| error=TRUE
# prints value of z
z
```

```{r}
# prints objects
ls()
```

Key points:

-   The global object `x` remains unchanged at 24, despite the fact that it's assigned the value 5 within `toy_function()`

-   The local object `x` only exists while the function runs

-   `Z` is created in the function’s local environment and disappears after the function finishes running
