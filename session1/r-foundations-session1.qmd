---
title: "R Foundations: Objects and Data Structures"
author: "Aditya Ranganath"
format: 
  html:
    toc: true 
    toc-depth: 2
    toc-expand: 2
    number-sections: true
    number-depth: 3
editor: visual
---

# R and R Studio Installation

If you haven't already, please go ahead and install both the R and RStudio applications. R and RStudio must be installed separately; you should install R first, and then RStudio. The R application is a bare-bones computing environment that supports statistical computing using the R programming language; RStudio is a visually appealing, feature-rich, and user-friendly interface that allows users to interact with this environment in an intuitive way. Once you have both applications installed, you don't need to open up R and RStudio separately; you only need to open and interact with RStudio (which will run R in the background).

Please follow these [instructions](https://posit.co/download/rstudio-desktop/#download) to download R and R Studio; make sure you download the version of R appropriate for your operating system.

# The R Studio Interface

Now that we've installed and opened up RStudio, let's familiarize ourselves with the RStudio interface. When we open up RStudio, we'll see a window that looks something like this:

```{r}
#| echo: false
#| fig-cap: "The R Studio Interface"
#| label: fig-plot-1
knitr::include_graphics('pictures/rstudio_window_revised.png')
```

If your interface doesn't look exactly like this, it shouldn't be a problem; we would expect to see minor cosmetic differences in the appearance of the interface across operating systems and computers (based on how they're configured). However, you should see four distinct windows within the larger RStudio interface:

-   The **top-left** window is known as the *Source* window.
    -   The *Source* window is where we can write our R scripts (including the code associated with this tutorial), and execute those scripts. We can also type in R code into the "Console" window (bottom-left window), but it is preferable to write our code in a script within the source window. That's because scripts can be saved (while code written into the console cannot); writing scripts therefore allows us to keep track of what we're doing, and facilitates the reproducibility of our work. Note that in some cases, we may not see a *Source* window when we first open RStudio. In that case, to start a new script, simply click the `File` button on the RStudio menu bar, scroll down to `New File` button, and then select `R Script` from the menu bar that opens up.
    -   It's also worth noting that the outputs of certain functions will appear in the *Source* window. In the context of our tutorial, when we want to view our datasets, we will use the `View()` function, which will display the relevant data within a new tab in the *Source* window.
-   The **top-right** window is the *Environment/History* pane of the RStudio interface.
    -   The "Environment" tab of this window provides information on the datasets we've loaded into RStudio, as well as objects we have defined (we'll talk about objects more later in the tutorial). -The "History" tab of the window provides a record of the R commands we've run in a given session.
-   The **bottom-right** window is the *Files/Plots/Packages/Help/Viewer* window.
    -   The "Files" tab displays our computer's directories and file structures and allows us to navigate through them without having to leave the R environment.
    -   The "Plots" tab is the tab where we can view any visualizations that we create. Within the "Plots" tab, make note of the "Zoom" button, which we can use to enlarge the display of our visualizations if they're too compressed in the "Plots" window. Also, note the "Export" button within the "Plots" tab (next to the "Zoom" button); we can use this button to export the displayed visualization to a .png or .jpeg file that can be used outside of RStudio.
    -   The "Packages" tab provides information on which packages have been installed, as well as which packages are currently loaded (more on packages in Sections 2.3 and 2.4 below)
    -   The "Help" tab displays documentation for R packages and functions. If you want to know more about how a package or function work, we can simply type a "?" followed by the package or function's name (no space between the question mark and the name) and relevant information will be displayed within the "Help" tab.
    -   The "Viewer" tab displays HTML output. If we write code that generates an HTML file, we can view it within the "Viewer" tab.
-   The **bottom-left** window is the *Console/Terminal/Jobs* window.
    -   The "Console" tab is where we can see our code execute when we run our scripts, as well as certain outputs produced by those scripts. In addition, if there are any error or warning messages, they will be printed to the "Console" tab. We can also type code directly into the console, but as we noted earlier, it is better practice to write our code in a script and then run it from there.
    -   The "Terminal", "Jobs" tabs are not relevant for our workshop. We'll briefly provide an overview of "R Markdown" towards the end of the lesson.

We're now ready to begin writing some basic code in R. Please go ahead and open up a new script, and follow along by typing the code as we go. To open up a new script, go to **File**, then click **New File**, then select **R Script**.

# R as a Calculator

At its most basic level, R can be used as a calculator. For instance:

```{r}
# calculates 2+2
2+2
```

When you type this code out in your script, it should look something like this:

```{r}
#| echo: false
#| fig-cap: "Starting an R Studio Script"
#| label: fig-plot 
knitr::include_graphics('pictures/script.png')
```

To run the code, you can highlight it and click the **Run** button (boxed in red). Alternatively, you can place the cursor on the line of code you'd like to run, and use a keyboard shortcut to run the code. On a Mac, the shortcut is clicking **Command** + **Shift** + **Return**. If you are using Windows, the keyboard shortcut to run the current line of code should be **Ctrl** + **Enter**.

You should go ahead and save the script in a convenient location by clicking **File** and then **Save As**. You should periodically save your work. After you close your R Session, you can always open your saved script, and quickly run the entire script to reproduce your work from prior sessions. To reproduce more than one line of code, entire script, simply highlight the entire script and click the **Run** button in the R Studio interface. On a Mac, the shortcut for running all of the code in your script is **Cmd** + **Option + R**. On a Windows machine, the shortcut to run the entirety of a script is **Ctrl** + **Shift** + **Enter**.

Before proceeding, one final thing you should note is that the actual code, `2+2`, was preceded by a "comment" that was preceded by a #; above, the comment was rather trivial, since it's fairly self evident what the code was doing. But pretty soon, our code will no longer be self evident, and code comments will be an essential way of documenting our work, and communicating with others who might read our code, as well as our future selves. The \# sign is always used to introduce a comment, and ensures that any text that comes after it will indeed be interpreted as a comment, rather than as code.

Now, let's try some more mathematical operations:

```{r}
# calculates 65 to the power of 4
65^4
```

```{r}
# calculates the sum of 24 and 4, divided by 7
(24+4)/7
```

```{r}
# calculates 2.78 subtracted from 10.453
10.453-2.78
```

While this is a useful and logical starting point, the possibility of assigning values to objects (or variables) considerably increases the scope of the operations we are able to carry out. We turn to object assignment in the next sub-section.

# Object Assignment and Manipulation

The concept of object (or variable) assignment is a fundamental concept when working in a scripting environment; indeed, the ability to easily assign values to objects is what allows us to easily and intuitively manipulate and process our data in a programmatic setting. To better understand the mechanics of object assignment, consider the following:

```{r}
# assign value 5 to new object named x
x<-5
```

In the code above, we use R's assignment operator, `<-` (i.e. a left-pointing arrow) to assign the value 5 to an object named `x`. Now that an object named `x` has been created and assigned the value 5, printing `x` in our console (or printing `x` in our script and running it) will return the value that has been assigned to the `x` object, i.e. 5:

```{r}
# prints value assigned to "x"
x
```

More generally, the process of assignment effectively equates the output created by the code on the right side of the assignment operator (`<-`) to an object with a name that is specified on the left side of the assignment operator. Whenever we want to look at the contents assigned to an object (i.e. the output created by the code to the right side of the assignment operator), we simply print the name of the object in the R console (or print the name and run it within a script).

Let's create another object, named `y`, and assign it the value "12":

```{r}
# assign value 12 to new object named y
y<-12
```

As we noted above, we can print the value that was assigned to `y` by printing the name of the object:

```{r}
# prints value assigned to "y"
y
```

Once objects are defined, it's possible to use those objects in arithmetic operations. For example:

```{r}
# prints the value of x + y
x+y
```

It's also possible to use existing objects to assign values to new ones. For example, we can assign the sum of `x` and `y` to a new object that we'll name `xy_sum`:

```{r}
# creates a new object, named "xy_sum" whose value is the sum of "x" and "y"
xy_sum<-x+y
```

Now, let's print the value of `xy_sum`that was created by the previous assignment operation:

```{r}
# prints value of of "xy_sum"
xy_sum
```

As expected, we see that the value assigned to `xy_sum` is "17" (i.e. the sum of the values assigned to `x` and `y`).

It is possible to change the value assigned to a given object. For example, let's say we want to change the value assigned to `x` from "5" to "8":

```{r}
# assign value of "8" to object named "x"
x<-8
```

We can confirm that `x` is now associated with the value "8", and the old value has been overwritten:

```{r}
# prints updated value of "x"
x
```

It's worth noting that updating the value assigned to `x` will not automatically update the value assigned to `xy_sum` (which, recall, is the sum of `x` and `y`). If we print the value assigned to `xy_sum`, note that it is still "17"):

```{r}
# print value assigned to xy_sum
xy_sum
```

In order for the value assigned to `xy_sum` to be updated with the new value of `x`, we must run the assignment operation again, with the updated value of x:

```{r}
# assigns sum of "y" and newly updated value of "x" to "xy_sum" object
xy_sum<-x+y
```

Now, the value of `xy_sum` should reflect the updated value of `x`, which we can confirm by printing the value of `xy_sum`:

```{r}
# prints value of "xy_sum"
xy_sum
```

Note that the value assigned to `xy_sum` is now "20" (the sum of "8" and "12"), rather than "17" (the sum of "5" and "12").

Thus far, we've been working with numeric values, but it's also possible to assign non-numeric contents to objects. For example, we can assign strings (i.e. lines of text) to objects. Below, consider the string "Boulder, CO" assigned to an object named `our_location:`

```{r}
# assigns string "Boulder, CO" to object named "our_location"
our_location<-"Boulder, CO"
```

We can print the string that has been assigned to the `our_location` object by typing the name of the object in our console, or running it from our script:

```{r}
# prints contents assigned to "our_location" object
our_location
```

## Naming Objects

While the examples above were very simple, we can assign virtually any R code, and by extension, the data structure(s) generated by that code (such as datasets, vectors, graphs/plots, functions etc.) to an R object. When naming your objects, try to be descriptive, so that the name of the object signifies something about the code or outputs assigned to it.

Note that generally speaking, you have a lot of flexibility in naming your R objects, but there are certain rules. For example, object names must start with a letter, and cannot contain any special symbols (they can only contain letters, numbers, underscores, and periods). Also, object names cannot contain multiple unconnected words; if you'd like to use multiple words or phrases, connect the discrete elements with an underscore (`_`), or use camel case (where different words are distinguished by beginning each discrete word begins with a capitalized letter). In addition, there are certain words that are "reserved" for other purposes, and therefore cannot be used in object names (i.e. `if`, `else`, `TRUE` , `FALSE`, etc).

It is also worth emphasizing that object names are case sensitive; in order to print the contents assigned to an object, that object's name must be printed *exactly* as it was created. For example, if we were to type `our_Location`, we would get an error, since there is no `our_Location` object (only an `our_location` object):

```{r}
#| error: TRUE
# prints contents of "our_Location"
our_Location

```

In order to keep track of the objects we have created, we can use the handy `ls()` function, which will print the names of all the objects that are in memory:

```{r}
# prints objects in memory
ls()
```

To delete an object from memory, you can pass it to the `rm()` function. For example, the following will delete the `our_location` object from memory:

```{r}
# deletes "our_location" object from memory
rm(our_location)
```

Now, we can confirm that the `our_location` object has indeed been deleted by running `ls()` once again:

```{r}
# prints objects in memory
ls()
```

# Data Structures

We now turn to a brief overview of some important data structures that help us to work with data in R. We will consider three data structures that are particularly useful: vectors, data frames, and lists. Note that this is not an exhaustive treatment of data structures in R; there are other structures, such as matrices and arrays, that are also important, and which you may encounter or use in your future work. However, for now, we will limit our discussion to vectors, data frames, and lists, since they are the data structures that are essential for getting started with data-based social scientific research in R, and the data structures that you will likely use most frequently.

## Vectors

In R, a vector is a sequence of values. A vector is created using the `c()` function. We'll discuss functions at greater later, but for now you can think of a function as a programmed command that takes inputs, and returns an output.

For example, let's make a vector to store the temperatures (in Celsius) of some cities in Asia. The `c()` function takes as its input a series of numbers, and returns as its output a numeric vector with those numbers as elements:

```{r}
# makes vector with values 32, 18, 41, 11
c(32, 18, 41, 11)
```

Recall that we can assign vectors to objects with descriptive names. Let's create a new vector object named `asia_temperatures_celsius` to store these values:

```{r}
# assigns vector of temperatures from Asian cities to a new object named "asia_temperatures_celsius"
asia_temperatures_celsius<-c(32, 18, 41, 11)
```

Now, whenever we want to print the vector assigned to the `asia_temperatures_celsius` object, we can simply print the name of the object:

```{r}
# prints contents of "asia_temperatures_celsius"
asia_temperatures_celsius
```

Though we have focused so far on numeric vectors (i.e. vectors where the elements are numbers), it is also possible to create vectors where the elements are strings (i.e. text). For example, let's create a vector that contains the names of cities that have a University of Colorado campus, and assign it to an object named `university_of_colorado_locations`

## Data Frames

## Lists
