---
title: "Processing, Wrangling and Analyzing Data in R"
author: "Aditya Ranganath"
format: 
  html:
    toc: true 
    toc-depth: 2
    toc-expand: 2
    number-sections: true
    number-depth: 3
editor: visual
---

# Introduction

# Installing Packages and Loading Libraries

```{r chunk1}
#| eval: FALSE

# Install packages using the "install.packages" function
install.packages("tidyverse")
install.packages("psych")
install.packages("janitor")
install.packages("fastDummies")
```

```{r chunk2}
#| eval: FALSE

# Installing multiple packages by passing package names as strings to the "install.packages" function
install.packages(c("tidyverse", "psych", "janitor", "fastDummies"))
```

```{r test3}
#| warning: FALSE
#| message: FALSE
# load libraries
library(tidyverse)
library(psych)
library(janitor)
library(fastDummies)
library(janitor)
library(summarytools)
```

```{r}
library(DT)
```

# Data Transfer: Reading Data into R

## Reading in Local Files

```{r test4}
#| include: false
setwd("/Users/adra7980/Library/CloudStorage/OneDrive-UCB-O365/Desktop/git-repositories/IBS_CRDDS_R_crashcourse/session3")
```

```{r}
# reads in the workshop dataset (Persson and Tabellini cross-national dataset) by passing the file path as an argument to the "read_csv" and assigns it to a new object named "pt"
pt<-read_csv("data/pt/persson_tabellini_workshop.csv")
```

```{r}
#| eval: FALSE

# Views the dataset in the R Studio data viewer
View(pt)
```

```{r}
#| echo: false
pt %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

## Reading in Data from Cloud Storage

# Processing, Wrangling, and Analyzing Numeric Data

```{r}
# makes a copy of "pt", called "pt_copy" that we can use for processing and analysis; keeps the original data frame, "pt" untouched
pt_copy<-pt
```

## Missing Data

## Summary Statistics

Once we have a dataset loaded into R, one of the first things we'll likely want to do after taking a look at the dataset in the viewer with the `View()` function is to get a sense of are data by calculating some summary statistics. This section reviews some summary statistics functions and tools we can call on for this purpose.

### Summary Statistics Tables

A quick way to generate a table of summary statistics is to use the `describe()` function from the *psych* package. Below, we’ll generate summary statistics for the `pt_copy` dataset by passing `pt_copy` as an argument to the `describe()` function, and assign the resulting table of summary statistics to a new object named `pt_copy_summarystats1`.

```{r}
# Generate summary statistics for "pt_copy" and assign table of summary statistics to a new object named "pt_copy_summarystats1"
pt_copy_summarystats1<-describe(pt_copy)
```

Let's go ahead and view the table of summary statistics. We can print the object to our console:

```{r}
# prints contents of "pt_copy_summarystats1" to console
pt_copy_summarystats1
```

Or, alternatively (and preferably), we can view the table in the data viewer:

```{r}
#| eval: false
# prints contents of "pt_copy_summarystats1" to console
View(pt_copy_summarystats1)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

To learn more about the `describe()` function, or any function you use in R, recall that you can query the function's documentation by printing a `?` following by the function's name in the console (or executing it within a script). For example:

```{r}
?describe
```

One thing to note here is that the function defaults to setting `na.rm=TRUE`; under this setting, the `describe()` function simply omits NA (i.e. missing) values when calculating summary statistics. If, instead, `na.rm=FALSE`, the function deletes all rows that contain missing data, and calculates summary statistics with reference to this truncated dataset that has been excised of missing values. In practical terms, it will typically make the most sense to go with the default `na.rm=TRUE` option, but it's important to be clear about these different options for handling missing data in the context of the `describe()` function. If you're still struggling to understand the difference, we can consider a simple example with a made-up toy dataset. Let's first create this dataset:

```{r}
# creates toy dataset for illustrative purposes and assigns it to object named "df_sample"
df_sample<-data.frame(Country=c("A", "B", "C", "D"),
                      Variable1=c(10, NA, 15, 20),
                      Variable2=c(5, 8, 12, NA))

# prints contents of "df_sample"
df_sample
```

Let's now generate a summary statistics table using `describe()` with the default `na.rm=TRUE` setting and assign it to an object named `df_sample_summary_default:`

```{r}
df_sample_summary_default<-describe(df_sample, na.rm=TRUE)
```

Go ahead and view \`\``df_sample_summary_default` in the data viewer:

```{r}
#| eval: false
View(df_sample_summary_default)
```

```{r}
#| echo: false
df_sample_summary_default %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note for example, that the mean of "Variable1" is 15 (i.e. the average of 10, 15, and 20) while the mean of "Variable2" is 12.5 (i.e. the average of 5, 8, and 12). When computing these averages, the `describe()` function simply ignores "NA", i.e. missing values. Now, let's use `describe()` to generate a summary statistics table, but set `na.rm=FALSE` ; we'll assign it to an object named `df_sample_summary_B` :

```{r}
df_sample_summary_B<-describe(df_sample, na.rm=FALSE)
```

Go ahead and inspect the summary table using the `View()` function:

```{r}
#| eval: false
View(df_sample_summary_B)
```

```{r}
#| echo: false
df_sample_summary_B %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note that the mean of "Variable1" is now 12.5 (the average of 10 and 15), because the `na.rm=FALSE` command removed both rows 1 and 3 in `df_sample` before performing the calculation, since both of these rows have an `NA` value in them. Similarly, the mean of "Variable2" is now 8.5 (the average of 5 and 12).

For the sake of argument, let's say you want to only calculate summary statistics for *columns* that have no missing values. The `describe()` function doesn't allow you to do this by specifying an argument, but we can carry out this task by writing a custom function. First, let's write a function that checks whether a vector has any missing values; we'll assign this object to a new object named `check_na().` This function takes a column as an input, and return a logical condition `TRUE` if there are any NA values in the column and `FALSE` if there are no NA values in the column:

```{r}
check_na<-function(column){
  any(is.na(column))
}

```

Let's test the function for a few columns in our dataset

```{r}
check_na(pt_copy$country)
```

```{r}
check_na(pt_copy$graft)
```

That worked. Now, let's call on the `discard()` function, which removes a vector from a data collection (such as a list or data frame) if some condition is met, and pass `pt_copy` and our `check_na()` function as arguments to it. In particular, the code below uses the `discard()` function to run the `check_na()` function across each column in `pt_copy;` if a column does have an NA value (i.e. evaluates to TRUE when the `check_na()` function is passed to it), it is "discarded", but if it does not have an NA value (i.e. evaluates to FALSE when the `check_na()` function is passed to it), it is kept. We're left with a version of `pt_copy()` without any columns that have NA values, which we'll assign to a new object named `pt_copy_NAcolumns_removed`:

```{r}
pt_copy_NAcolumns_removed<-discard(pt_copy, check_na)
```

We can confirm that all of the columns with NA values have been removed by passing `pt_copy_NAcolumns_removed` to the `View()` function:

```{r}
#| eval: false
View(pt_copy_NAcolumns_removed)
```

```{r}
#| echo: false
pt_copy_NAcolumns_removed %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Now, we can pass `pt_copy_NAcolumns_removed` as an argument to the `describe()` function, and thereby generate a table of summary statistics for only variables without any missing observations. Below, we'll assign this table of summary statistics to a new object named `pt_copy_NAcolumns_removed_summarystats`:

```{r}
pt_copy_NAcolumns_removed_summarystats<-describe(pt_copy_NAcolumns_removed)
```

Let's go ahead and view this table in the data viewer:

```{r}
#| eval: false
View(pt_copy_NAcolumns_removed_summarystats)
```

```{r}
#| echo: false
pt_copy_NAcolumns_removed_summarystats %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Let's say, for the sake of argument, that we will be working with a lot of datasets, and you will want to quickly generate tables of summary statistics that exclude variables that have missing values. We don't want to go through these steps all the time, so we can wrap this code into a function that takes a dataset as an input, and returns a table of summary statistics that excludes information on variables with missing values:

```{r}
# creates function to take dataset input and return a table of summary statistics only for variables that have no missing values
summary_stats_noNAcolumns<-function(dataset_input){
  cleaned_dataset<-discard(dataset_input, check_na)
  cleaned_summary_stats<-describe(cleaned_dataset)
  return(cleaned_summary_stats)
}
  
```

Now, we can simply pass a dataset as an argument to our custom `summary_stats_noNAcolumns` function, and it will return a summary statistics table with these desired specifications. Test this function out on `pt_copy` to confirm it works:

```{r}
summary_stats_noNAcolumns(pt_copy)
```

For further confirmation, create a toy dataset and pass it as an argument to `summary_stats_noNAcolumns()` to ensure that it works as expected.

It might be the case that the summary statistics table created by `describe()` does not contain information you'd like, in which case it may be possible to customize it to provide that information. For example, it could be nice to have a column in the summary statistics table that provides information on the number of NA values there are for each variable. To get that information into the summary statistics table, we'll first write a function to count the number of NA values in a vector:

```{r}
# Define a named function to count missing values
count_missing <- function(x) {
  sum(is.na(x))
}
```

Next, we'll apply this function to each column/variable in `pt_copy`, and deposit the number of missing values for each column in a vector, such that the number of missing values in the first column is deposited as the first element in the vector, the number of missing values in the second column is deposited as the second element in the vector, and so on; we'll assign this vector to a new object named `missing_values_vector`:

```{r}
missing_values_vector <- map_dbl(pt_copy, count_missing)
```

Now, we'll add this vector to `pt_copy_summarystats1`:

```{r}
# adds "missing_values_vector" as a column named "missing" to "pt_copy_summarystats1" summary stats table
pt_copy_summarystats1$missing<-missing_values_vector
```

View `pt_copy_summarystats1` in the data viewer to confirm that the column has been successfully added:

```{r}
#| eval: false
View(pt_copy_summarystats1)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Below, we'll learn another way of adding new columns to datasets that draws on the *tidyverse*; the syntax above is from base R.

Finally, there may be instances in which the summary statistics table produced by the `describe()` function provides unwanted information. For example, the summary statistics table provides summary statistics for categorical variables as well as numeric ones, but quantitative summary statistics for categorical information may not be meaningful, and simply clutter things. What if we want to remove categorical variables from the table of summary statistics?

We can first use the `select_if()` function from *dplyr* (a data-wrangling package that is part of the *tidyverse* suite) to select only the numeric columns in `pt_copy`. We'll assign this "numeric only" version of `pt_copy` to a new object named `pt_copy_numeric`:

```{r}
pt_copy_numeric<-select_if(pt_copy, is.numeric)
```

We can confirm that `pt_copy_numeric` only contains numeric variables:

```{r}
#| eval: false
# views "pt_copy_numeric" in data viewer
View(pt_copy_numeric)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Before proceeding, it's useful to note that there are other summary statistics packages that are worth exploring. For example, the *summarytools* package provides the `descr()` , which is similar to `describe()` from the *psych* package. The *summarytools* package defaults to providing information as a matrix, which we haven't covered, so we pass `descr(pt_copy)` to the `as.data.frame()` function to get the summary statistics table output as a data frame.

```{r}
pt_summary_ST<-as.data.frame(descr(pt_copy))
```

```{r}
#| eval: false
# views "pt_copy_numeric" in data viewer
View(pt_summary_ST)
```

```{r}
#| echo: false
pt_summary_ST %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

The *summarytools* package also provides some useful functions for generating frequency tables and crosstabs, to which we now turn.

## Frequency Tables and Crosstabs

```{r}
# creates frequency table for the continent variable
freq(pt_copy$continent)
```

```{r}
table(pt_copy$continent, pt_copy$federal)
```

## Group-Level Summary Statistics

## Data Cleaning and Preparation

### Rearranging Columns

### Renaming Variables

### Sorting Datasets With Respect to Variables

### Creating New Variables Based on Existing Variables

### Selecting or Deleting Variables

### Recoding Variables

### Subsetting Variables

# Elementary Data Analysis

## Computing Correlations

## Basic Regression Models

## Regression Diagnostics

## Creating and Exporting Regression Tables

# Working With Multiple Datasets

## Reading in Multiple Datasets

```{r}
# prints the names of the files we want to read in and assigns the vector of strings to a new object named "worldbank_filenames" 
worldbank_filenames<-list.files("data/wb")
```

```{r}
# reads world bank files into a list that is assigned to an object named "world_bank_list"
setwd("data/wb")
world_bank_list<-map(worldbank_filenames, read_csv)
```

```{r}
# prints contents of "world_bank_list"
world_bank_list
```

```{r}
# removes CSV extension from "worldbank_filenames"
worldbank_filenames_base<-str_remove(worldbank_filenames, ".csv")
```

```{r}
# assigns names to datasets in "world_bank_list"
names(world_bank_list)<-worldbank_filenames_base
```

```{r}
# extracts fdi dataset from "world_bank_list" by assigned name
world_bank_list[["wdi_fdi2019"]]
```

## Joining Data

## Appending Data

```{r}
# extracts worldbank FDI data from "world_bank_list" and assigns it to the object "worldbank_fdi_2019"
worldbank_fdi_2019<-world_bank_list[["wdi_fdi2019"]]

# extracts worldbank trade data from "world_bank_list" and assigns it to the object "worldbank_trade_2019"
worldbank_trade_2019<-world_bank_list[["wdi_trade2019"]]
```

```{r}
# Appends "worldbank_trade_2019" to "worldbank_fdi_2019" and assigns new dataset to object named "worldbank_trade_fdi"
worldbank_trade_fdi<-bind_rows(worldbank_fdi_2019, worldbank_trade_2019)
```

```{r}
worldbank_trade_fdi<-worldbank_trade_fdi %>% drop_na()
                                        
```

```{r}
worldbank_trade_fdi_clean<-worldbank_trade_fdi %>%  
  rename("Country"="Country Name",
          "CountryCode"="Country Code",
          "Series"="Series Name",
           "variable"="2019 [YR2019]",
            "SeriesCode"="Series Code") %>% 
     mutate(ID = row_number())
  
```

## Reshaping Data

```{r}
# reshapes "worldbank_trade_fdi" from long to wide
worldbank_trade_fdi_wide<-worldbank_trade_fdi_clean %>% 
                            pivot_wider(names_from=SeriesCode,
                                        values_from=variable)
                            
```

```{r}
worldbank_trade_fdi_wide
```

## Automating Data Processing with Functions

```{r}
# write function to World Bank dataset
worldbank_cleaning_function<-function(input_dataset){
  modified_dataset<-input_dataset %>% 
                      select(-"Series Code") %>% 
                      rename("Country"="Country Name",
                             "CountryCode"="Country Code",
                             "Series"="Series Name",
                             "2019"="2019 [YR2019]") %>% 
                      drop_na(CountryCode)
  return(modified_dataset)
}
```

```{r}
# Iteratively apply "worldbank_cleaning_function" to all of the datasets in "world_bank_list", and deposit the cleaned datasets into a new list named "world_bank_list_cleaned"
world_bank_list_cleaned<-map(world_bank_list, worldbank_cleaning_function)
```

# Exporting Data

## Exporting a Data Frame

## Exporting Multiple Data Frames

```{r}
# create file names for exported World Bank files
WB_filenames_export<-paste0("outputs/", worldbank_filenames_base, "_cleaned.csv")
```

```{r}
# exports datasets in "world_bank_list_cleaned" to "outputs" directory using filenames in "WB_filenames_export"
walk2(world_bank_list_cleaned, WB_filenames_export, write_csv)
```
