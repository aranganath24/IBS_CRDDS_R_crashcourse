---
title: "Processing, Wrangling and Analyzing Data in R"
author: "Aditya Ranganath"
format: 
  html:
    toc: true 
    toc-depth: 2
    toc-expand: 2
    number-sections: true
    number-depth: 3
editor: visual
---

# Introduction

# Installing Packages and Loading Libraries

```{r chunk1}
#| eval: FALSE

# Install packages using the "install.packages" function
install.packages("tidyverse")
install.packages("psych")
install.packages("janitor")
install.packages("fastDummies")
```

```{r chunk2}
#| eval: FALSE

# Installing multiple packages by passing package names as strings to the "install.packages" function
install.packages(c("tidyverse", "psych", "janitor", "fastDummies"))
```

```{r test3}
#| warning: FALSE
#| message: FALSE
# load libraries
library(tidyverse)
library(psych)
library(janitor)
library(fastDummies)
library(janitor)
library(summarytools)
```

```{r}
library(DT)
```

# Data Transfer: Reading Data into R

## Reading in Local Files

```{r test4}
#| include: false
setwd("/Users/adra7980/Library/CloudStorage/OneDrive-UCB-O365/Desktop/git-repositories/IBS_CRDDS_R_crashcourse/session3")
```

```{r}
# reads in the workshop dataset (Persson and Tabellini cross-national dataset) by passing the file path as an argument to the "read_csv" and assigns it to a new object named "pt"
pt<-read_csv("data/pt/persson_tabellini_workshop.csv")
```

```{r}
#| eval: FALSE

# Views the dataset in the R Studio data viewer
View(pt)
```

```{r}
#| echo: false
pt %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

## Reading in Data from Cloud Storage

# Processing, Wrangling, and Analyzing Numeric Data

```{r}
# makes a copy of "pt", called "pt_copy" that we can use for processing and analysis; keeps the original data frame, "pt" untouched
pt_copy<-pt
```

## Missing Data

## Summary Statistics

Once we have a dataset loaded into R, one of the first things we'll likely want to do after taking a look at the dataset in the viewer with the `View()` function is to get a sense of are data by calculating some summary statistics. This section reviews some summary statistics functions and tools we can call on for this purpose.

### Summary Statistics Tables

A quick way to generate a table of summary statistics is to use the `describe()` function from the *psych* package. Below, we’ll generate summary statistics for the `pt_copy` dataset by passing `pt_copy` as an argument to the `describe()` function, and assign the resulting table of summary statistics to a new object named `pt_copy_summarystats1`.

```{r}
# Generate summary statistics for "pt_copy" and assign table of summary statistics to a new object named "pt_copy_summarystats1"
pt_copy_summarystats1<-describe(pt_copy)
```

Let's go ahead and view the table of summary statistics. We can print the object to our console:

```{r}
# prints contents of "pt_copy_summarystats1" to console
pt_copy_summarystats1
```

Or, alternatively (and preferably), we can view the table in the data viewer:

```{r}
#| eval: false
# prints contents of "pt_copy_summarystats1" to console
View(pt_copy_summarystats1)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

To learn more about the `describe()` function, or any function you use in R, recall that you can query the function's documentation by printing a `?` following by the function's name in the console (or executing it within a script). For example:

```{r}
?describe
```

One thing to note here is that the function defaults to setting `na.rm=TRUE`; under this setting, the `describe()` function simply omits NA (i.e. missing) values when calculating summary statistics. If, instead, `na.rm=FALSE`, the function deletes all rows that contain missing data, and calculates summary statistics with reference to this truncated dataset that has been excised of missing values. In practical terms, it will typically make the most sense to go with the default `na.rm=TRUE` option, but it's important to be clear about these different options for handling missing data in the context of the `describe()` function. If you're still struggling to understand the difference, we can consider a simple example with a made-up toy dataset. Let's first create this dataset:

```{r}
# creates toy dataset for illustrative purposes and assigns it to object named "df_sample"
df_sample<-data.frame(Country=c("A", "B", "C", "D"),
                      Variable1=c(10, NA, 15, 20),
                      Variable2=c(5, 8, 12, NA))

# prints contents of "df_sample"
df_sample
```

Let's now generate a summary statistics table using `describe()` with the default `na.rm=TRUE` setting and assign it to an object named `df_sample_summary_default:`

```{r}
df_sample_summary_default<-describe(df_sample, na.rm=TRUE)
```

Go ahead and view \`\``df_sample_summary_default` in the data viewer:

```{r}
#| eval: false
View(df_sample_summary_default)
```

```{r}
#| echo: false
df_sample_summary_default %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note for example, that the mean of "Variable1" is 15 (i.e. the average of 10, 15, and 20) while the mean of "Variable2" is 12.5 (i.e. the average of 5, 8, and 12). When computing these averages, the `describe()` function simply ignores "NA", i.e. missing values. Now, let's use `describe()` to generate a summary statistics table, but set `na.rm=FALSE` ; we'll assign it to an object named `df_sample_summary_B` :

```{r}
df_sample_summary_B<-describe(df_sample, na.rm=FALSE)
```

Go ahead and inspect the summary table using the `View()` function:

```{r}
#| eval: false
View(df_sample_summary_B)
```

```{r}
#| echo: false
df_sample_summary_B %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note that the mean of "Variable1" is now 12.5 (the average of 10 and 15), because the `na.rm=FALSE` command removed both rows 1 and 3 in `df_sample` before performing the calculation, since both of these rows have an `NA` value in them. Similarly, the mean of "Variable2" is now 8.5 (the average of 5 and 12).

For the sake of argument, let's say you want to only calculate summary statistics for *columns* that have no missing values. The `describe()` function doesn't allow you to do this by specifying an argument, but we can carry out this task by writing a custom function. First, let's write a function that checks whether a vector has any missing values; we'll assign this object to a new object named `check_na().` This function takes a column as an input, and return a logical condition `TRUE` if there are any NA values in the column and `FALSE` if there are no NA values in the column:

```{r}
check_na<-function(column){
  any(is.na(column))
}

```

Let's test the function for a few columns in our dataset

```{r}
check_na(pt_copy$country)
```

```{r}
check_na(pt_copy$graft)
```

That worked. Now, let's call on the `discard()` function, which removes a vector from a data collection (such as a list or data frame) if some condition is met, and pass `pt_copy` and our `check_na()` function as arguments to it. In particular, the code below uses the `discard()` function to run the `check_na()` function across each column in `pt_copy;` if a column does have an NA value (i.e. evaluates to TRUE when the `check_na()` function is passed to it), it is "discarded", but if it does not have an NA value (i.e. evaluates to FALSE when the `check_na()` function is passed to it), it is kept. We're left with a version of `pt_copy()` without any columns that have NA values, which we'll assign to a new object named `pt_copy_NAcolumns_removed`:

```{r}
pt_copy_NAcolumns_removed<-discard(pt_copy, check_na)
```

We can confirm that all of the columns with NA values have been removed by passing `pt_copy_NAcolumns_removed` to the `View()` function:

```{r}
#| eval: false
View(pt_copy_NAcolumns_removed)
```

```{r}
#| echo: false
pt_copy_NAcolumns_removed %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Now, we can pass `pt_copy_NAcolumns_removed` as an argument to the `describe()` function, and thereby generate a table of summary statistics for only variables without any missing observations. Below, we'll assign this table of summary statistics to a new object named `pt_copy_NAcolumns_removed_summarystats`:

```{r}
pt_copy_NAcolumns_removed_summarystats<-describe(pt_copy_NAcolumns_removed)
```

Let's go ahead and view this table in the data viewer:

```{r}
#| eval: false
View(pt_copy_NAcolumns_removed_summarystats)
```

```{r}
#| echo: false
pt_copy_NAcolumns_removed_summarystats %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Let's say, for the sake of argument, that we will be working with a lot of datasets, and you will want to quickly generate tables of summary statistics that exclude variables that have missing values. We don't want to go through these steps all the time, so we can wrap this code into a function that takes a dataset as an input, and returns a table of summary statistics that excludes information on variables with missing values:

```{r}
# creates function to take dataset input and return a table of summary statistics only for variables that have no missing values
summary_stats_noNAcolumns<-function(dataset_input){
  cleaned_dataset<-discard(dataset_input, check_na)
  cleaned_summary_stats<-describe(cleaned_dataset)
  return(cleaned_summary_stats)
}
  
```

Now, we can simply pass a dataset as an argument to our custom `summary_stats_noNAcolumns` function, and it will return a summary statistics table with these desired specifications. Test this function out on `pt_copy` to confirm it works:

```{r}
summary_stats_noNAcolumns(pt_copy)
```

For further confirmation, create a toy dataset and pass it as an argument to `summary_stats_noNAcolumns()` to ensure that it works as expected.

It might be the case that the summary statistics table created by `describe()` does not contain information you'd like, in which case it may be possible to customize it to provide that information. For example, it could be nice to have a column in the summary statistics table that provides information on the number of NA values there are for each variable. To get that information into the summary statistics table, we'll first write a function to count the number of NA values in a vector:

```{r}
# Define a named function to count missing values
count_missing <- function(x) {
  sum(is.na(x))
}
```

Next, we'll apply this function to each column/variable in `pt_copy`, and deposit the number of missing values for each column in a vector, such that the number of missing values in the first column is deposited as the first element in the vector, the number of missing values in the second column is deposited as the second element in the vector, and so on; we'll assign this vector to a new object named `missing_values_vector`:

```{r}
missing_values_vector <- map_dbl(pt_copy, count_missing)
```

Now, we'll add this vector to `pt_copy_summarystats1`:

```{r}
# adds "missing_values_vector" as a column named "missing" to "pt_copy_summarystats1" summary stats table
pt_copy_summarystats1$missing<-missing_values_vector
```

View `pt_copy_summarystats1` in the data viewer to confirm that the column has been successfully added:

```{r}
#| eval: false
View(pt_copy_summarystats1)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Below, we'll learn another way of adding new columns to datasets that draws on the *tidyverse*; the syntax above is from base R.

Finally, there may be instances in which the summary statistics table produced by the `describe()` function provides unwanted information. For example, the summary statistics table provides summary statistics for categorical variables as well as numeric ones, but quantitative summary statistics for categorical information may not be meaningful, and simply clutter things. What if we want to remove categorical variables from the table of summary statistics?

We can first use the `select_if()` function from *dplyr* (a data-wrangling package that is part of the *tidyverse* suite) to select only the numeric columns in `pt_copy`. We'll assign this "numeric only" version of `pt_copy` to a new object named `pt_copy_numeric`:

```{r}
pt_copy_numeric<-select_if(pt_copy, is.numeric)
```

We can confirm that `pt_copy_numeric` only contains numeric variables:

```{r}
#| eval: false
# views "pt_copy_numeric" in data viewer
View(pt_copy_numeric)
```

```{r}
#| echo: false
pt_copy_summarystats1 %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Before proceeding, it's useful to note that there are other summary statistics packages that are worth exploring. For example, the *summarytools* package provides the `descr()` , which is similar to `describe()` from the *psych* package. The *summarytools* package defaults to providing information as a matrix, which we haven't covered, so we pass `descr(pt_copy)` to the `as.data.frame()` function to get the summary statistics table output as a data frame.

```{r}
pt_summary_ST<-as.data.frame(descr(pt_copy))
```

```{r}
#| eval: false
# views "pt_copy_numeric" in data viewer
View(pt_summary_ST)
```

```{r}
#| echo: false
pt_summary_ST %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

The *summarytools* package also provides some useful functions for generating frequency tables and crosstabs, to which we now turn.

## Frequency Tables and Crosstabs

```{r}
# creates frequency table for the continent variable
freq(pt_copy$continent)
```

```{r}
table(pt_copy$continent, pt_copy$federal)
```

## Group-Level Summary Statistics

While having a simple table of summary statistics is a useful starting point, it is often useful to generate group-level summary statistics, where summary statistics are presented for different subgroups in the dataset. One way to generate group summary statistics is to use the `describeBy()` function (also from the *psych* package), where the first argument is the data frame you would like to generate group-level summary statistics for, and the second argument is the column that contains the relevant groups. Below, we generate summary statistics for `pt_copy` parsed out by the different continents in the "continent" column. The expression `pt_copy$continent` indicates that the groups with respect to which we want to calcualte the summary statistics is in the "continent" column of the `pt_copy` data frame. More generally, we can explicitly refer to columns in an R data frame using this dollar-sign notation, where the expression before the dollar sign refers to the data frame object, and the expression after refers to the name of the column.

The `describeBy()` function will produce a list that contains summary statistics for different groups as list elements. Below, we'll assign the list of group summary statistics to a new object named `summary_stats_by_continent`:

```{r}
# Creates summary statistics for each continent grouping, and puts results in list named "summary_stats_by_continent"
summary_stats_by_continent<-describeBy(pt_copy, pt_copy$continent)
```

Now, let's say we want to extract the summary statistics for Africa, one of the continent categories in the "continent" column. We can do so using the double-bracket notation we discussed above:

```{r}
# Accessing continent-level summary statistics for africa from the "summary_stats_by_continent" list
summary_stats_by_continent[["africa"]]
```

Recall that we can assign list elements that we extract from a list to their own object, which allows us to conveniently retrieve it whenever it is needed. Below, we'll assign the summary statistics for Africa to a new object named `africa_summary`:

```{r}
# Group-level summary statistics can be assigned to their own object for easy retrieval
africa_summary<-summary_stats_by_continent[["africa"]]
```

Another convenient way to extract group-level statistics is with the *dplyr* package's `group_by()` function. First, we'll run the code below, and assign it to a new object named `trade_age_by_continent`:

```{r}
# Generate a table that displays summary statistics for trade at the continent level and assign to object named "trade_age_by_continent"
trade_age_by_continent<-pt_copy %>% 
                          group_by(continent) %>% 
                            summarise(meanTrade=mean(trade),sdTrade=sd(trade),
                                      meanAge=mean(age), sdAge=sd(age),
                                      n=n())
```

Let's now print the contents of `trade_age_by_continent`:

```{r}
# prints contents of "trade_age_by_continent"
trade_age_by_continent
```

Let's now unpack the code that created this table. We started with the `pt_copy` data frame, and then used `group_by(continent)` to declare that subsequent calculations should be performed at the continent-level; then, within the `summarise()` function, we defined the column names we wanted to use in the group-level summary table, and how those variables are to be calculated. For example, `meanTrade=mean(trade)` indicates that we want the first column to be named "meanTrade", which is to be calculated by taking the mean of the "trade" variable for each continent grouping. After that, `sdTrade=sd(trade)` indicates that we want the second column to be named "sdTrade", which is to be calculated by taking the standard deviation of the "trade" variable for each continent grouping. And so on. Note that `n=n()` indicates that we want the final column, named "n", to provide information about the number of observations in each continent-level grouping.

You might have noticed a mysterious symbol in the above code that comes immediately after `pt_copy`, and immediately after `group_by(continent)`. This symbol is known as a “pipe” (`%>%`). The pipe operator effectively takes the contents to its left, and then uses these contents as an input to the code on its right. Above, the pipe takes the contents of `pt_copy` on its left, and then feeds this data into the `group_by()` function on the right; then, after grouping the data by continent, it feeds this grouped data on its left into the `summarise()` function on its right. We will use the pipe operator throughout the lesson to chain together functions in this manner.

## Data Cleaning and Wrangling

After getting a sense of your data by computing some summary statistics and running some crosstabs, you'll often have a sense of how you would like to clean or transform your data for analysis. This section briefly describes some functions that are useful for these basic data-preparation and wrangling tasks. Most of these functions are from the *tidyverse*'s *dplyr* package.

### Rearranging Columns

We can manipulate the order of the columns in a dataset using the `relocate` function. For example, the code below uses the `relocate()` function to shift the "country" column to the front of the dataset, and then assigns this change back to `pt_copy` to update the object:

```{r}
# bring the "country" column to the front of the dataset
pt_copy<-pt_copy %>% relocate(country)
```

Go ahead and confirm that the change has been implemented by viewing `pt_copy` in the data viewer:

```{r}
#| eval: false
# Views "pt_copy" in data viewer
View(pt_copy)
```

```{r}
#| echo: false
pt_copy %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

We can specify more than one argument to the `relocate` function. For example, in the code below, passing the "country", "list", "trade", and "oecd" variables/columns to the `relocate()` function will make "country" the first column, "list" the second column, "trade" the third column, and so on.

```{r}
# bring the "country", "list", "trade", "oecd" columns to the front of the dataset
pt_copy<-pt_copy %>% relocate(country, list, trade, oecd)
```

Let's go ahead and view the updated dataset in the R Studio Viewer:

```{r}
#| eval: false
# Views updated "pt_copy" data frame in data viewer
View(pt_copy)
```

```{r}
#| echo: false
pt_copy %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

### Renaming Variables

In order to rename variables, we can use the `rename()` function, as below. The code below renames the existing "list" variable to "party_list", which is more descriptive, and assigns the change back to the `pt_copy` object.

```{r}
## Renaming a variable (renames "list" to "party_list")
pt_copy<-pt_copy %>% rename(party_list=list)
```

Let's check the `pt_copy` data frame in the viewer to ensure that the change has been made.

```{r}
#| eval: false
# Views updated "pt_copy" data frame in data viewer
View(pt_copy)
```

```{r}
#| echo: false
pt_copy %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

You can rename more than one variable at a time using the `rename()` function; simply separate the arguments by a comma. For example, if we wanted to also change the variable currently named "ctrycd" to "country_code", in addition to changing "list" to "party_list", we could use the following expression: `pt_copy<-pt_copy %>% rename(party_list=list, country_code=ctrycd)`

### Sorting Datasets With Respect to Variables

It is often useful to sort a data frame in ascending or descending order with respect to a given variable. The code below sorts the `pt_copy` data frame in ascending order with respect to the "trade" variable using the `arrange()` function:

```{r}
# sorting in ascending (low to high) order with respect to the "trade" variable
pt_copy<-pt_copy %>% arrange(trade)
```

If, instead, you want to sort the dataset in descending order with respect to the "trade" variable, pass the name of the variable to the `desc()` function within the `arrange()` function, as below:

```{r}
# sorting in descending (high to low) order with respect to the "trade" variable
pt_copy<-pt_copy %>% arrange(desc(trade))
```

Note that it's also possible to pass several arguments to the arrange function, and thereby sort a dataset with respect to multiple variables; for example, the code below first relocates the "continent" column and the "trade" column towards the front of the dataset (just after "Country), then sorts the dataset by continent, and then further sorts it in descending order by trade. This allows us to quickly note the country in each continent grouping with the highest value on the "trade" variable.

```{r}
# takes the "pt_copy" dataset, relocates "country", "continent", and "trade" to the front of the dataset, and then arranges the dataset based on the "continent" variable, then in descending order with respect to the "trade" variable
pt_copy<-pt_copy %>% 
        relocate(country, continent, trade) %>% 
        arrange(continent, desc(trade))
```

Let's go ahead and see what this looks like using the Viewer:

```{r}
#| eval: false
# Views updated "pt_copy" data frame in data viewer
View(pt_copy)
```

```{r}
#| echo: false
pt_copy %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Sorting a dataset with respect to more than one variable can be especially useful in certain contexts, particularly in cases where you're dealing with nested data. For example, in a time series dataset, it can be useful to first sort by year, then by months within the year. In a dataset with regional information, it could be helpful to first sort by regional, then by cities within those regional groupings.

### Creating New Variables Based on Existing Variables

Depending on your research question and empirical strategy, it is often useful or necessary to create new variables in your dataset, based on existing variables. To do so, we can use *dplyr's* `mutate()` function. The code below, for example, uses the `mutate()` function to create a new variable, named "non_catholic_80", that is computed by subtracting the existing "catho80" variable from 100; for convenience, the "country", "catho80", and newly created "non_catholic_80" variables are all moved to the front of the dataset using the `relocate()` function:

```{r}
# Create new variable named "non_catholic_80" that is calculated by substracting the Catholic share of the population in 1980 ("catho80") from 100  and relocates "country", "catho80", and the newly created "non_catholic_80" to the front of the dataset
pt_copy<-pt_copy %>% mutate(non_catholic_80=100-catho80) %>% 
                     relocate(country, catho80, non_catholic_80)
```

We can view the updated `pt_copy` data frame to confirm that the new variable has been created:

```{r}
#| eval: false
# Views updated "pt_copy" data frame in data viewer
View(pt_copy)
```

```{r}
#| echo: false
pt_copy %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Note that it's possible to define more than one new variable at a time using `mutate()`; simply separate the arguments by a comma within the `mutate()` function.

### Selecting or Deleting Variables

Sometimes, we will have a dataset with many variables, and to make things more tractable, we'll want to select only the variables that are relevant to our analysis. we can explicitly select desired variables using the `select()` function from *dplyr*. The code below selects the "country", "cgexp", "cgrev", "trade", and "federal" columns from `pt_copy`, and then assigns this selection to a new object named `pt_copy_selection`:

```{r}
# Selects "country", "cgexp", "cgrev", and "trade" variables from the "pt_copy" dataset and assigns the selection to a new object named "pt_copy_selection"
pt_copy_selection<-pt_copy %>% 
                    select(country, cgexp, cgrev, trade, federal)
```

When we view the `pt_copy_selection` object in the data viewer, we'll see that we now have a new data frame that consists only of these variables:

```{r}
#| eval: false
# views "pt_copy_selection" in data viewer
View(pt_copy_selection)
```

```{r}
#| echo: false
# prints updated contents of "pt_copy"
pt_copy_selection %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Sometimes, it could make more sense to directly delete columns, instead of deciding on which ones to keep or select. For example, the code below deletes the "federal" variable from `pt_copy_selection` by passing it to the `select()` column with a "-" in front of it.

```{r}
# deletes "federal" variable from "pt_copy_selection"
pt_copy_selection %>% select(-federal)
```

If you want to delete multiple columns, simply specify the columns in a vector, preceded by a minus sign, that is passed to the `select()` function. The code below, for instance, takes the existing `pt_copy_selection` data frame, deletes the "federal" and "trade" columns, and assigns the result to a new object named `pt_copy_selection_modified`:

```{r}
# deletes "federal" and "trade" from "pt_copy_selection" and assigns it to new object named "pt_copy_selection_modified"
pt_copy_selection_modified<-pt_copy_selection %>% select(-c(federal, trade))
```

Check the `pt_copy_selection_modified` data frame in the data viewer to confirm these changes:

```{r}
#| eval: false
# views "pt_copy_selection_modified" in data viewer
View(pt_copy_selection_modified)
```

```{r}
#| echo: false
pt_copy_selection_modified %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

### Recoding Variables

"Recoding" a variable refers to the process of taking an existing variable, and generating new variable(s) that represent the information from that original variable in a new way. Below, we'll consider some common recoding operations.

### Creating Dummy Variables from Continuous Numeric Variables

### Subsetting (Filtering) Variables

# Elementary Data Analysis

## Computing Correlations

## Basic Regression Models

## Regression Diagnostics

## Creating and Exporting Regression Tables

# Working With Multiple Datasets

## Reading in Multiple Datasets

```{r}
# prints the names of the files we want to read in and assigns the vector of strings to a new object named "worldbank_filenames" 
worldbank_filenames<-list.files("data/wb")
```

```{r}
# reads world bank files into a list that is assigned to an object named "world_bank_list"
setwd("data/wb")
world_bank_list<-map(worldbank_filenames, read_csv)
```

```{r}
# prints contents of "world_bank_list"
world_bank_list
```

```{r}
# removes CSV extension from "worldbank_filenames"
worldbank_filenames_base<-str_remove(worldbank_filenames, ".csv")
```

```{r}
# assigns names to datasets in "world_bank_list"
names(world_bank_list)<-worldbank_filenames_base
```

```{r}
# extracts fdi dataset from "world_bank_list" by assigned name
world_bank_list[["wdi_fdi2019"]]
```

## Joining Data

## Appending Data

```{r}
# extracts worldbank FDI data from "world_bank_list" and assigns it to the object "worldbank_fdi_2019"
worldbank_fdi_2019<-world_bank_list[["wdi_fdi2019"]]

# extracts worldbank trade data from "world_bank_list" and assigns it to the object "worldbank_trade_2019"
worldbank_trade_2019<-world_bank_list[["wdi_trade2019"]]
```

```{r}
# Appends "worldbank_trade_2019" to "worldbank_fdi_2019" and assigns new dataset to object named "worldbank_trade_fdi"
worldbank_trade_fdi<-bind_rows(worldbank_fdi_2019, worldbank_trade_2019)
```

```{r}
worldbank_trade_fdi<-worldbank_trade_fdi %>% drop_na()
                                        
```

```{r}
worldbank_trade_fdi_clean<-worldbank_trade_fdi %>%  
  rename("Country"="Country Name",
          "CountryCode"="Country Code",
          "Series"="Series Name",
           "variable"="2019 [YR2019]",
            "SeriesCode"="Series Code") %>% 
     mutate(ID = row_number())
  
```

## Reshaping Data

```{r}
# reshapes "worldbank_trade_fdi" from long to wide
worldbank_trade_fdi_wide<-worldbank_trade_fdi_clean %>% 
                            pivot_wider(names_from=SeriesCode,
                                        values_from=variable)
                            
```

```{r}
worldbank_trade_fdi_wide
```

## Automating Data Processing with Functions

```{r}
# write function to World Bank dataset
worldbank_cleaning_function<-function(input_dataset){
  modified_dataset<-input_dataset %>% 
                      select(-"Series Code") %>% 
                      rename("Country"="Country Name",
                             "CountryCode"="Country Code",
                             "Series"="Series Name",
                             "2019"="2019 [YR2019]") %>% 
                      drop_na(CountryCode)
  return(modified_dataset)
}
```

```{r}
# Iteratively apply "worldbank_cleaning_function" to all of the datasets in "world_bank_list", and deposit the cleaned datasets into a new list named "world_bank_list_cleaned"
world_bank_list_cleaned<-map(world_bank_list, worldbank_cleaning_function)
```

# Exporting Data

## Exporting a Data Frame

## Exporting Multiple Data Frames

```{r}
# create file names for exported World Bank files
WB_filenames_export<-paste0("outputs/", worldbank_filenames_base, "_cleaned.csv")
```

```{r}
# exports datasets in "world_bank_list_cleaned" to "outputs" directory using filenames in "WB_filenames_export"
walk2(world_bank_list_cleaned, WB_filenames_export, write_csv)
```
